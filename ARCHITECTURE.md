# RobotBaseN 工程架构文档

## 1. 工程概述

RobotBaseN 是一个基于龙芯 2K300 处理器的嵌入式机器人控制系统，专为移动机器人平台设计。系统采用分层架构设计，集成了传感器数据采集、运动控制、算法处理和通信功能。

### 1.1 工程目标
- 实现机器人的运动控制（电机驱动、PWM控制）
- 集成多种传感器（IMU、雷达、超声波等）
- 提供实时数据处理和算法支持
- 支持串口通信和数据输出

### 1.2 运行环境
- **目标平台**: 龙芯 2K300 (Loongson 2K300)
- **架构**: LoongArch64
- **内存**: 256MB RAM
- **启动地址**: 0x9000000000800000 (Cached)

---

## 2. 整体架构设计

### 2.1 架构层次图

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层 (Application)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  algorithms │  │    kmp      │  │   业务逻辑任务       │  │
│  │  (算法模块)  │  │ (字符串匹配) │  │                     │  │
│  └──────┬──────┘  └─────────────┘  └─────────────────────┘  │
├─────────┼───────────────────────────────────────────────────┤
│         │              外设管理层 (Peripherals)              │
│         │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐  │
│         │  │  GPIO   │ │ MPU6050 │ │ Readar  │ │ UART_DMA│  │
│         │  │ (HAL)   │ │  (IMU)  │ │ (雷达)  │ │(串口DMA)│  │
│         │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘  │
│         │       └───────────┴───────────┴───────────┘       │
│         │                      │                            │
│         │              消息队列总线 (MQ Bus)                 │
│         │       ┌───────────────────────────┐               │
│         └──────►│  supersonic_to_redar      │               │
│                 │  redar_to_serial          │               │
│                 │  redar_to_algorithm       │               │
│                 └───────────────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│                   操作系统抽象层 (OSAL)                      │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌────────┐ │
│  │  Task   │ │  Event  │ │   MQ    │ │  Mutex  │ │  Sem   │ │
│  │ (任务)  │ │ (事件)  │ │(消息队列)│ │ (互斥)  │ │(信号量)│ │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └────────┘ │
├─────────────────────────────────────────────────────────────┤
│                   伪操作系统 (PesudoOS)                      │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌───────────────────┐  │
│  │ 任务调度 │ │  定时器  │ │  中断   │ │   上下文切换       │  │
│  │         │ │         │ │  处理   │ │   (setjmp)       │  │
│  └─────────┘ └─────────┘ └─────────┘ └───────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│              板级支持包 (BSP) / 硬件抽象层                    │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌────────┐ │
│  │  UART   │ │   I2C   │ │   PWM   │ │   GPIO  │ │  DMA   │ │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └────────┘ │
├─────────────────────────────────────────────────────────────┤
│                    硬件层 (Hardware)                         │
│              龙芯 2K300 SoC + 外设芯片                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心设计原则

1. **分层架构**: 清晰的层次划分，降低模块间耦合
2. **消息驱动**: 基于消息队列的异步通信机制
3. **可移植性**: OSAL 层提供操作系统抽象，支持多种RTOS
4. **可扩展性**: 模块化设计，便于添加新功能
5. **实时性**: 伪操作系统提供轻量级任务调度

---

## 3. 核心模块划分与职责

### 3.1 模块层次结构

| 层级 | 模块 | 职责描述 |
|------|------|----------|
| 应用层 | algorithms | 实现KMP匹配算法，处理雷达数据匹配 |
| 应用层 | kmp | 字符串/数组匹配算法库 |
| 外设层 | peripherals | 统一管理外设模块，创建共享消息队列 |
| 外设层 | gpio | GPIO初始化和引脚复用配置 |
| 外设层 | mpu6050 | IMU传感器驱动，读取加速度和陀螺仪数据 |
| 外设层 | readar | 超声波雷达驱动，通过I2C读取距离数据 |
| 外设层 | readar_rotate | 雷达旋转控制，PWM驱动舵机扫描 |
| 外设层 | uart_dma | 串口DMA通信，数据输出 |
| OS层 | osal | 操作系统抽象接口 |
| OS层 | pesudoos | 轻量级协作式多任务调度 |
| BSP层 | bsp | 板级支持包，硬件初始化 |

### 3.2 详细模块说明

#### 3.2.1 应用层模块

**algorithms 模块**
- **文件**: `APP/algorithms.c`, `APP/algorithms.h`
- **职责**: 
  - 实现基于KMP算法的数据匹配任务
  - 从雷达数据队列接收360度扫描数据
  - 计算角度偏移量(delta_theta)
- **关键函数**: `algorithms_init()`, `algorithms_get_delta_theta()`

**kmp 模块**
- **文件**: `APP/kmp.c`, `APP/kmp.h`
- **职责**:
  - 提供KMP字符串匹配算法实现
  - 构建LPS (Longest Prefix Suffix) 数组
  - 在数据流中搜索模式匹配
- **关键函数**: `kmp_build_lps()`, `kmp_search()`

#### 3.2.2 外设管理层

**peripherals 模块**
- **文件**: `src/peripherals.c`, `src/peripherals.h`
- **职责**:
  - 集中管理所有外设模块的初始化
  - 创建共享消息队列，实现模块间解耦
  - 提供队列访问接口
- **消息队列**:
  - `supersonic_to_redar`: 超声波到雷达数据 (24字节, 10条)
  - `redar_to_serial`: 雷达到串口数据 (1080字节, 3条)
  - `redar_to_algorithm`: 雷达到算法数据 (1440字节, 3条)

**gpio 模块 (HAL层)**
- **文件**: `src/hal/gpio/gpio.c`, `src/hal/gpio/gpio.h`
- **职责**:
  - 配置GPIO引脚功能和复用模式
  - 初始化电机控制引脚 (PWM输出)
  - 初始化I2C引脚
- **关键配置**:
  - GPIO 64/65: 电机控制
  - GPIO 86/87: 备用功能
  - GPIO 50/51: I2C总线
  - GPIO 44/45: I2C总线

**mpu6050 模块 (IMU驱动)**
- **文件**: `src/drivers/mpu6050/mpu6050.c`
- **职责**:
  - 通过I2C接口与MPU6050通信
  - 读取加速度(X, Y)和陀螺仪(Z轴)数据
  - 计算速度、位移和角度
- **数据流**: 加速度 → 速度积分 → 位移积分

**readar 模块 (超声波雷达)**
- **文件**: `src/drivers/readar/readar.c`
- **职责**:
  - 通过I2C读取超声波传感器数据
  - 发送测量命令并接收距离数据
  - 将数据发送到消息队列
- **I2C地址**: 0x57
- **数据格式**: 3字节 (距离数据)

**readar_rotate 模块 (雷达旋转控制)**
- **文件**: `src/drivers/readar/readar_rotate.c`
- **职责**:
  - 控制PWM舵机进行360度扫描
  - 每个角度位置读取一次超声波数据
  - 将扫描数据分发到串口和算法队列
- **PWM配置**: 周期20ms，脉宽0.5-2.5ms

**uart_dma 模块 (串口通信)**
- **文件**: `src/drivers/uart/uart_dma.c`
- **职责**:
  - 初始化UART2，波特率115200
  - 通过DMA方式发送雷达扫描数据
  - 支持大数据量高效传输

#### 3.2.3 操作系统层

**osal 模块 (操作系统抽象层)**
- **文件**: `BareMetal/osal/osal.h`
- **职责**:
  - 提供统一的OS接口抽象
  - 支持多种RTOS后端 (RT-Thread, FreeRTOS, uC/OS, PesudoOS)
- **提供的功能**:
  - 任务管理: 创建、删除、挂起、恢复
  - 同步机制: 事件、信号量、互斥锁
  - 通信机制: 消息队列
  - 定时器管理

**pesudoos 模块 (伪操作系统)**
- **文件**: `BareMetal/PesudoOS/pesudoos.h`, `pesudo_task.h`
- **职责**:
  - 实现轻量级协作式多任务调度
  - 基于setjmp/longjmp实现上下文切换
  - 提供任务状态管理
- **任务状态**:
  - IDLE: 空闲状态
  - READY: 就绪状态
  - RUNNING: 运行状态
  - SUSPEND: 挂起状态
  - SLEEP: 休眠状态
  - BLOCKED: 阻塞状态(等待mutex/sem/event/mq)

#### 3.2.4 BSP层

**bsp 模块 (板级支持包)**
- **文件**: `include/bsp.h`, `src/bsp_start_hook.c`
- **职责**:
  - 硬件初始化配置
  - 设备使能控制 (UART, I2C, SPI, PWM等)
  - 启动钩子函数
- **支持的设备**:
  - UART: 0,1,2,4,5,6 (可配置)
  - I2C: 0,1,2,3 (可配置)
  - PWM: 0,1,2,3 (可配置)
  - 其他: SPI, CAN, GMAC, ADC, I2S等

---

## 4. 模块间交互关系

### 4.1 模块依赖图

```
                         main.c
                           │
           ┌───────────────┼───────────────┐
           │               │               │
           ▼               ▼               ▼
    peripherals_init() algorithms_init() pesudoos_run()
           │               │
           ▼               ▼
    ┌─────────────┐   ┌─────────────┐
    │ peripherals │   │  algorithms │
    │    模块     │   │    模块     │
    └──────┬──────┘   └──────┬──────┘
           │                 │
    ┌──────┴──────┐          │ 获取队列
    │             │          ▼
    ▼             ▼    ┌─────────────┐
┌─────────┐  ┌────────┐│ peripherals │
│  gpio   │  │mpu6050 ││_get_redar_  │
│  init   │  │ init   ││to_algorithm │
└─────────┘  └────────┘└─────────────┘
    │
    ▼
┌─────────┐  ┌─────────────┐  ┌──────────┐
│ readar  │  │readar_rotate│  │uart_dma  │
│  init   │  │   init      │  │  init    │
└────┬────┘  └──────┬──────┘  └────┬─────┘
     │              │              │
     ▼              ▼              ▼
┌─────────────────────────────────────────┐
│           消息队列 (Message Queue)       │
│  ┌─────────────────────────────────┐    │
│  │  supersonic_to_redar            │    │
│  │  (超声波数据 → 雷达旋转模块)      │    │
│  ├─────────────────────────────────┤    │
│  │  redar_to_serial                │    │
│  │  (雷达数据 → 串口输出)           │    │
│  ├─────────────────────────────────┤    │
│  │  redar_to_algorithm             │    │
│  │  (雷达数据 → 算法处理)           │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

### 4.2 数据流向图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          数据流向图                                  │
└─────────────────────────────────────────────────────────────────────┘

【传感器数据采集流程】

┌─────────────┐     I2C      ┌─────────────┐     MQ      ┌─────────────┐
│  超声波传感器 │◄────────────►│  readar模块  │──────────►│supersonic_  │
│  (硬件)      │   读取距离    │  (数据采集)  │  发送数据   │to_redar队列 │
└─────────────┘              └─────────────┘             └──────┬──────┘
                                                                │
                                                                ▼
┌─────────────┐              ┌─────────────┐             ┌─────────────┐
│   PWM舵机   │◄────────────►│readar_rotate│◄────────────│  消息队列   │
│  (扫描驱动)  │  角度控制    │  (扫描控制)  │   接收数据   │             │
└─────────────┘              └──────┬──────┘             └─────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ▼               ▼               ▼
            ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
            │redar_to_    │ │redar_to_    │ │  本地处理    │
            │serial队列   │ │algorithm队列│ │  (角度数组)  │
            └──────┬──────┘ └──────┬──────┘ └─────────────┘
                   │               │
                   ▼               ▼
            ┌─────────────┐ ┌─────────────┐
            │ uart_dma    │ │ algorithms  │
            │ (串口输出)   │ │ (KMP匹配)   │
            └─────────────┘ └──────┬──────┘
                                   │
                                   ▼
                            ┌─────────────┐
                            │ delta_theta │
                            │ (角度偏移量) │
                            └─────────────┘

【IMU数据采集流程】

┌─────────────┐     I2C      ┌─────────────┐
│  MPU6050    │◄────────────►│  mpu6050    │
│  (IMU芯片)   │  读取传感器   │  模块       │
└─────────────┘   数据       │  (数据处理)  │
                             │             │
                             │ 加速度积分   │
                             │  ───────► 速度 │
                             │ 速度积分     │
                             │  ───────► 位移 │
                             │ 陀螺仪积分   │
                             │  ───────► 角度 │
                             └─────────────┘
```

### 4.3 交互接口定义

| 模块A | 模块B | 交互方式 | 接口/数据格式 |
|-------|-------|----------|---------------|
| main | peripherals | 函数调用 | `peripherals_init()` |
| main | algorithms | 函数调用 | `algorithms_init()` |
| peripherals | gpio | 函数调用 | `gpio_init()` |
| peripherals | mpu6050 | 函数调用 | `mpu6050_init()` |
| peripherals | readar | 函数调用 | `readar_init()` |
| peripherals | readar_rotate | 函数调用 | `readar_rotate_init()` |
| peripherals | uart_dma | 函数调用 | `uart_dma_init()` |
| readar | readar_rotate | 消息队列 | `supersonic_to_redar` (3字节数据) |
| readar_rotate | uart_dma | 消息队列 | `redar_to_serial` (1080字节) |
| readar_rotate | algorithms | 消息队列 | `redar_to_algorithm` (1440字节) |
| algorithms | kmp | 函数调用 | `kmp_search()`, `kmp_build_lps()` |

---

## 5. 技术栈选型及理由

### 5.1 编程语言

| 技术 | 版本/标准 | 选型理由 |
|------|-----------|----------|
| C语言 | C99 | 嵌入式系统标准语言，高效、可控、硬件亲和 |

### 5.2 目标平台

| 组件 | 规格 | 选型理由 |
|------|------|----------|
| 处理器 | 龙芯 2K300 | 国产自主可控，LoongArch64架构 |
| 内存 | 256MB | 满足嵌入式应用需求 |
| 时钟 | 1GHz+ | 提供充足计算能力 |

### 5.3 操作系统

| 组件 | 类型 | 选型理由 |
|------|------|----------|
| PesudoOS | 协作式调度 | 轻量级、低开销、易于调试 |
| OSAL | 抽象层 | 支持多种RTOS，便于移植 |

**为什么不使用完整RTOS？**
1. 资源受限环境，需要最小化内存占用
2. 任务数量少，协作式调度足够
3. 简化上下文切换，使用setjmp实现
4. 避免复杂的抢占式调度开销

### 5.4 通信协议

| 协议 | 用途 | 选型理由 |
|------|------|----------|
| I2C | 传感器通信 | 标准协议，多设备支持，引脚少 |
| UART | 调试/数据输出 | 简单可靠，广泛支持 |
| DMA | 大数据传输 | 减轻CPU负担，高效传输 |

### 5.5 算法库

| 算法 | 用途 | 选型理由 |
|------|------|----------|
| KMP | 模式匹配 | O(n)时间复杂度，适合实时匹配 |

### 5.6 开发工具链

| 工具 | 用途 |
|------|------|
| LoongArch GCC | 交叉编译器 |
| Newlib | C标准库 |
| GDB | 调试工具 |

---

## 6. 关键业务流程说明

### 6.1 系统启动流程

```
┌─────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  上电    │───►│  启动代码    │───►│  BSP初始化   │───►│  创建队列    │
│  复位    │    │  _start     │    │  bsp_start  │    │ peripherals │
└─────────┘    └─────────────┘    └──────┬──────┘    └──────┬──────┘
                                         │                   │
                                         ▼                   ▼
                                  ┌─────────────┐    ┌─────────────┐
                                  │  初始化外设  │    │ 初始化算法   │
                                  │ peripherals │    │ algorithms  │
                                  │   _init()   │    │   _init()   │
                                  └──────┬──────┘    └─────────────┘
                                         │
                    ┌────────────────────┼────────────────────┐
                    ▼                    ▼                    ▼
             ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
             │  gpio_init  │      │mpu6050_init │      │ readar_init │
             └─────────────┘      └─────────────┘      └──────┬──────┘
                                                               │
                    ┌────────────────────┬────────────────────┘
                    ▼                    ▼
             ┌─────────────┐      ┌─────────────┐
             │readar_rotate│      │ uart_dma    │
             │   _init()   │      │   _init()   │
             └─────────────┘      └─────────────┘
                    │
                    ▼
             ┌─────────────┐
             │ 主循环运行   │
             │pesudoos_run │
             │ (0)死循环   │
             └─────────────┘
```

### 6.2 雷达扫描流程

```
开始扫描
    │
    ▼
┌─────────────────┐
│ 初始化PWM输出   │◄────────────────┐
│ 设置初始角度    │                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 循环360个角度   │                 │
│ for t = 0 to 359│                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 计算PWM脉宽     │                 │
│ hi = 500+2000*t │                 │
│    /360         │                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 启动PWM输出     │                 │
│ 驱动舵机转动    │                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 等待50ms稳定    │                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 从队列接收      │                 │
│ 超声波数据      │                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 存储数据到数组  │                 │
│ ANGLE[t] = data │                 │
└────────┬────────┘                 │
         │                          │
         ▼                          │
┌─────────────────┐                 │
│ 停止PWM输出     │─────────────────┘ (下一个角度)
└────────┬────────┘
         │
         ▼ (360次循环结束)
┌─────────────────┐
│ 发送数据到      │
│ serial队列      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 发送数据到      │
│ algorithm队列   │
└────────┬────────┘
         │
         ▼
        结束
```

### 6.3 算法处理流程

```
算法任务启动
    │
    ▼
┌─────────────────┐
│ 获取算法队列    │
│ redar_to_       │
│ algorithm       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 等待接收数据    │
│ 360个角度值     │
│ (阻塞等待)      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 复制当前数据    │
│ 作为模式串      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 构建双倍长度    │
│ 文本串 tem[720] │
│ tem[i] = angle  │
│ tem[i+360] =    │
│   angle         │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 构建LPS数组     │
│ kmp_build_lps() │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ KMP搜索匹配     │
│ kmp_search()    │
│ 在tem中搜索     │
│ angle模式       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 计算偏移量      │
│ delta_theta =   │
│ match_index     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 等待下一次      │
│ 扫描数据        │
└────────┬────────┘
         │
         └──────────────────► (循环等待)
```

### 6.4 任务调度流程

```
主循环 pesudoos_run(0)
    │
    ▼
┌─────────────────────────┐
│ 遍历所有任务            │
│ for each task in list   │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 检查任务状态            │
│ - 是否就绪?             │
│ - 是否超时?             │
│ - 是否可运行?           │
└───────────┬─────────────┘
            │
    ┌───────┴───────┐
    ▼               ▼
┌─────────┐   ┌─────────────┐
│ 就绪    │   │ 阻塞/休眠   │
│ RUNNING │   │ BLOCKED/    │
│         │   │ SLEEP       │
└────┬────┘   └─────────────┘
     │
     ▼
┌─────────────────────────┐
│ 执行任务入口函数        │
│ task->handler()         │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 任务阻塞?               │
│ (等待MQ/Mutex/Sem/Event)│
└───────────┬─────────────┘
            │
    ┌───────┴───────┐
    ▼               ▼
┌─────────┐   ┌─────────────┐
│ 是      │   │ 否          │
│ 保存    │   │ 任务完成/   │
│ 上下文  │   │ 继续运行    │
│ setjmp  │   │             │
└────┬────┘   └──────┬──────┘
     │               │
     │               ▼
     │        ┌─────────────┐
     │        │ 更新任务    │
     │        │ 统计信息    │
     │        └──────┬──────┘
     │               │
     └───────────────┤
                     ▼
            ┌─────────────┐
            │ 切换到      │
            │ 下一个任务  │
            └──────┬──────┘
                   │
                   └──────────────► (继续遍历)
```

---

## 7. 系统边界与外部依赖

### 7.1 系统边界

```
┌─────────────────────────────────────────────────────────────┐
│                      RobotBaseN 系统边界                     │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  系统内部                            │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐  │   │
│  │  │ 算法处理 │  │ 任务调度 │  │ 消息队列 │  │ 数据融合│  │   │
│  │  └─────────┘  └─────────┘  └─────────┘  └────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│          ┌───────────────┼───────────────┐                  │
│          │               │               │                  │
│          ▼               ▼               ▼                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   传感器    │  │   执行器    │  │   通信接口   │         │
│  │  接口层     │  │   接口层    │  │   接口层    │         │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘         │
└─────────┼────────────────┼────────────────┼────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────┐
│                      外部硬件设备                            │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │ MPU6050 │  │ 超声波   │  │ PWM舵机 │  │ UART设备│         │
│  │ (I2C)   │  │ 传感器   │  │         │  │         │         │
│  └─────────┘  │ (I2C)   │  └─────────┘  └─────────┘         │
│               └─────────┘                                    │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 外部依赖清单

#### 7.2.1 硬件依赖

| 设备 | 接口 | 用途 | 依赖程度 |
|------|------|------|----------|
| MPU6050 | I2C1 | IMU数据采集 | 高 |
| 超声波传感器 | I2C1 | 距离测量 | 高 |
| PWM舵机 | PWM0 | 雷达扫描 | 高 |
| UART2 | UART | 数据输出 | 中 |

#### 7.2.2 软件依赖

| 依赖项 | 版本 | 用途 | 替代方案 |
|--------|------|------|----------|
| Newlib | 最新 | C标准库 | 可自定义实现 |
| BSP库 | 定制 | 硬件驱动 | 必须依赖 |

#### 7.2.3 接口契约

**I2C设备接口**
```c
// 初始化
int I2C_initialize(int bus);

// 发送起始信号
int I2C_send_start(int bus, uint8_t addr);

// 发送地址
int I2C_send_addr(int bus, uint8_t addr, int is_read);

// 写字节
int I2C_write_bytes(int bus, uint8_t *data, int len);

// 读字节
int I2C_read_bytes(int bus, uint8_t *data, int len);

// 发送停止信号
int I2C_send_stop(int bus, uint8_t addr);
```

**PWM接口**
```c
typedef struct {
    int mode;           // PWM模式
    int hi_ns;          // 高电平时间(ns)
    int lo_ns;          // 低电平时间(ns)
} pwm_cfg_t;

int ls2k_pwm_pulse_start(int dev, pwm_cfg_t *cfg);
int ls2k_pwm_pulse_stop(int dev);
```

**UART接口**
```c
int UART_initialize(int dev, int baudrate);
int ls2k_uart_open(int dev, void *arg);
int ls2k_uart_ioctl(int dev, int cmd, void *arg);
```

---

## 8. 扩展性设计考虑

### 8.1 模块化设计

```
┌─────────────────────────────────────────────────────────────┐
│                     扩展性架构设计                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   应用扩展层                         │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │ 新算法  │ │ 路径规划│ │ 避障逻辑│ │ 用户接口│   │   │
│  │  │ 模块    │ │ 模块    │ │ 模块    │ │ 模块    │   │   │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘   │   │
│  │       └───────────┴───────────┴───────────┘        │   │
│  │                      │                              │   │
│  │                      ▼                              │   │
│  │              ┌─────────────┐                        │   │
│  │              │  标准API接口 │                        │   │
│  │              │ peripherals │                        │   │
│  │              └──────┬──────┘                        │   │
│  └─────────────────────┼───────────────────────────────┘   │
│                        │                                    │
│  ┌─────────────────────┼───────────────────────────────┐   │
│  │                   外设扩展层                         │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │ 新传感器│ │ 新执行器│ │ 通信模块│ │ 存储模块│   │   │
│  │  │ 驱动    │ │ 驱动    │ │         │ │         │   │   │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘   │   │
│  │       └───────────┴───────────┴───────────┘        │   │
│  │                      │                              │   │
│  │                      ▼                              │   │
│  │              ┌─────────────┐                        │   │
│  │              │   OSAL API  │                        │   │
│  │              │  (标准接口)  │                        │   │
│  │              └──────┬──────┘                        │   │
│  └─────────────────────┼───────────────────────────────┘   │
│                        │                                    │
│  ┌─────────────────────┼───────────────────────────────┐   │
│  │                   硬件抽象层                         │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │  I2C   │ │  SPI    │ │  UART   │ │  CAN    │   │   │
│  │  │  驱动   │ │  驱动   │ │  驱动   │ │  驱动   │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 扩展点设计

#### 8.2.1 添加新传感器

1. **创建驱动文件**: `src/drivers/new_sensor/new_sensor.c`
2. **实现标准接口**:
   ```c
   void new_sensor_init(void);
   int new_sensor_read(void *data);
   ```
3. **注册到peripherals**: 在 `peripherals_init()` 中添加调用
4. **创建消息队列** (如需要): 使用 `osal_mq_create()`

#### 8.2.2 添加新算法

1. **创建算法文件**: `APP/new_algorithm.c`
2. **实现初始化函数**: `void new_algorithm_init(void)`
3. **创建处理任务**: 使用 `osal_task_create()`
4. **注册到main**: 在 `main()` 中调用初始化函数

#### 8.2.3 添加新通信协议

1. **创建通信模块**: `src/drivers/comm/new_protocol.c`
2. **实现协议栈**: 封装/解封装逻辑
3. **集成到数据流**: 连接到消息队列系统

### 8.3 配置扩展

通过 `bsp.h` 中的宏定义进行功能开关:

```c
// 使能新功能
#define BSP_USE_NEW_SENSOR  1
#define BSP_USE_NEW_PROTOCOL 1

// 在初始化中添加条件编译
#if BSP_USE_NEW_SENSOR
    new_sensor_init();
#endif
```

---

## 9. 安全架构

### 9.1 安全设计原则

1. **输入验证**: 所有外部数据都需验证
2. **资源限制**: 任务栈大小、队列长度都有上限
3. **错误处理**: 所有错误都有处理路径
4. **隔离性**: 模块间通过消息队列通信，降低耦合

### 9.2 安全机制

#### 9.2.1 栈溢出保护

```c
// pesudo_task.h
#define PESUDO_STACK_MAGIC  0xdeadbeaf5555aaaaULL

// 任务结构体包含栈信息
struct pesudo_task {
    uint32_t  stack_size;       // 栈大小限制
    size_t   *stack_base;       // 栈基址
    size_t    stack_cur_top;    // 当前栈顶
    volatile uint32_t error;    // 错误标志
};

// 栈溢出检测
#define PT_FATAL_STACK_OV   0x0001
```

#### 9.2.2 队列溢出保护

```c
// 队列创建时指定最大消息数
osal_mq_t mq = osal_mq_create("queue", 0, item_size, max_msgs);

// 发送时检查队列是否已满
int osal_mq_is_full(osal_mq_t mq);
```

#### 9.2.3 超时机制

```c
// 所有阻塞操作都支持超时
#define OSAL_WAIT_FOREVER       0xFFFFFFFF

// 接收消息带超时
int osal_mq_receive(mq, msg, size, timeout_ms);

// 任务错误标志
#define PT_TIMEOUT_MQ       0x0800
```

### 9.3 故障处理

| 故障类型 | 检测方式 | 处理策略 |
|----------|----------|----------|
| 栈溢出 | 魔数检查 | 标记错误，停止任务 |
| 队列满 | 返回码检查 | 丢弃数据或等待 |
| 超时 | 超时返回值 | 重试或错误处理 |
| I2C错误 | 返回值检查 | 重试初始化 |

---

## 10. 性能优化策略

### 10.1 内存优化

#### 10.1.1 静态分配策略

```c
// 使用静态数组而非动态分配
static uint8_t ANGleforEVEDIS[360*3] = {0};  // 雷达数据缓冲区
static int angle_for_now[360] = {0};          // 算法缓冲区
```

#### 10.1.2 栈大小优化

```c
// 根据任务需求分配栈空间
osal_task_create("task", 
    4096,   // 4KB栈空间
    0, 0, 
    handler, NULL);
```

### 10.2 计算优化

#### 10.2.1 算法复杂度

- **KMP算法**: O(n)时间复杂度，适合实时匹配
- **积分计算**: 固定时间间隔，避免浮点运算

#### 10.2.2 中断与轮询

```c
// 使用DMA减轻CPU负担
ls2k_uart_ioctl(BSP_USE_UART2, UART_WORK_DMA, NULL);

// 协作式调度，避免忙等
delay_ms(10);  // 让出CPU
```

### 10.3 通信优化

#### 10.3.1 批量数据传输

```c
// 一次发送360个点的数据
uint8_t angeledistan[3*360] = {0};
osal_mq_receive(q, angeledistan, sizeof(angeledistan), ...);
```

#### 10.3.2 零拷贝设计

消息队列传递指针而非复制数据（在资源允许时）。

### 10.4 实时性保证

| 优化策略 | 实现方式 | 效果 |
|----------|----------|------|
| 固定周期 | 定时器触发 | 确定性时序 |
| 优先级调度 | 任务优先级设置 | 关键任务优先 |
| 中断处理 | 快速中断响应 | 低延迟 |
| 批处理 | 数据缓存后批量处理 | 减少切换开销 |

---

## 11. 部署架构

### 11.1 编译构建流程

```
源代码
   │
   ▼
┌─────────────────┐
│  预处理 (CPP)   │
│  宏展开/头文件  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  编译 (GCC)     │
│  .c → .o        │
│  LoongArch64    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  链接 (LD)      │
│  使用ld.script  │
│  生成ELF        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  二进制转换     │
│  ELF → 烧录格式 │
└────────┬────────┘
         │
         ▼
    目标设备
```

### 11.2 内存布局

```
地址空间布局 (LoongArch64)

0x9000_0000_0000_0000 ─────────────────────────────
                    │                              │
                    │      Cached 区域              │
                    │                              │
0x9000_0000_0080_0000 ─────────────────────────────  ← 代码起始地址
                    │      .text (代码段)           │
                    │      - 程序代码               │
                    │      - 只读数据               │
                    ├──────────────────────────────┤
                    │      .data (数据段)           │
                    │      - 初始化变量             │
                    ├──────────────────────────────┤
                    │      .bss (未初始化数据)       │
                    │      - 全局变量               │
                    │      - 静态变量               │
                    ├──────────────────────────────┤
                    │      Heap (堆)                │
                    │      - 动态分配               │
                    ├──────────────────────────────┤
                    │      Stack (栈)               │
                    │      - 任务栈                 │
                    │      - 16KB 系统栈            │
                    │                              │
                    └──────────────────────────────┘

0x8000_0000_0000_0000 ─────────────────────────────
                    │      UnCached 区域            │
                    │      (设备寄存器映射)          │
                    └──────────────────────────────┘
```

### 11.3 启动流程

```
┌─────────────┐
│    上电     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  BootROM    │
│  加载程序    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   _start    │
│  启动代码    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  初始化硬件  │
│  - 内存     │
│  - 时钟     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ bsp_start_  │
│ hook1()     │
│ - 控制台    │
│ - 文件系统  │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ bsp_start_  │
│ hook2()     │
│ - EMMC      │
│ - USB       │
│ - Shell     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│    main()   │
│  应用入口    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ peripherals │
│ _init()     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ algorithms_ │
│ init()      │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ pesudoos_   │
│ run(0)      │
│ 主循环      │
└─────────────┘
```

### 11.4 部署清单

| 组件 | 文件 | 位置 | 说明 |
|------|------|------|------|
| 可执行文件 | robotbasen.elf | 目标设备内存 | 主程序 |
| 链接脚本 | ld.script | 编译时使用 | 内存布局定义 |
| 编译配置 | compile_flags.txt | 编译时使用 | 头文件路径和宏定义 |
| BSP库 | libbsp.a | 链接时使用 | 板级支持包 |

---

## 12. 总结

RobotBaseN 是一个设计精良的嵌入式机器人控制系统，具有以下特点：

### 12.1 架构优势

1. **分层清晰**: 应用层、外设层、OS层、BSP层职责分明
2. **松耦合**: 消息队列机制实现模块间解耦
3. **可移植**: OSAL抽象层支持多种RTOS
4. **可扩展**: 模块化设计便于功能扩展
5. **高效**: 轻量级协作式调度，资源占用低

### 12.2 核心能力

1. **传感器融合**: MPU6050 IMU + 超声波雷达
2. **运动控制**: PWM舵机精确控制
3. **实时处理**: KMP算法快速匹配
4. **数据通信**: DMA高效数据传输

### 12.3 适用场景

- 教育机器人平台
- 自主导航小车
- 环境感知系统
- 机器人原型开发

---

## 附录

### A. 文件清单

```
robotbasen/
├── main.c                      # 主程序入口
├── compile_flags.txt           # 编译配置
├── ld.script                   # 链接脚本
│
├── APP/                        # 应用层
│   ├── algorithms.c/h          # 算法模块
│   ├── kmp.c/h                 # KMP算法库
│
├── src/                        # 源代码
│   ├── peripherals.c/h         # 外设管理
│   ├── bsp_start_hook.c        # BSP启动钩子
│   ├── drivers/                # 设备驱动
│   │   ├── mpu6050/            # IMU驱动
│   │   ├── readar/             # 雷达驱动
│   │   └── uart/               # 串口驱动
│   └── hal/gpio/               # GPIO HAL
│
├── BareMetal/                  # 操作系统层
│   ├── osal/osal.h             # OS抽象层
│   └── PesudoOS/               # 伪操作系统
│       ├── pesudoos.h
│       └── pesudo_task.h
│
├── include/                    # 头文件
│   └── bsp.h                   # BSP配置
│
└── ls2k300/                    # 平台相关
    └── misc/                   # 工具函数
```

### B. 术语表

| 术语 | 说明 |
|------|------|
| OSAL | Operating System Abstraction Layer，操作系统抽象层 |
| BSP | Board Support Package，板级支持包 |
| HAL | Hardware Abstraction Layer，硬件抽象层 |
| KMP | Knuth-Morris-Pratt，字符串匹配算法 |
| IMU | Inertial Measurement Unit，惯性测量单元 |
| DMA | Direct Memory Access，直接内存访问 |
| PWM | Pulse Width Modulation，脉冲宽度调制 |
| I2C | Inter-Integrated Circuit，集成电路总线 |
| UART | Universal Asynchronous Receiver/Transmitter，通用异步收发器 |
| MQ | Message Queue，消息队列 |

---

*文档版本: 1.0*  
*生成日期: 2026-02-13*  
*作者: AI Assistant*
